<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Colour Cannon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        canvas {
            background: #222;
            cursor: url("cursor.svg"), crosshair;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
</body>
<script>
    let columns = 50;
    let radius = 10;
    let spawnRate = 1000/60;
</script>
<script>
    let canvas = document.querySelector('#canvas');
    let context = canvas.getContext('2d');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas)

    let mouseDown = 0;
    document.body.onmousedown = function () {
        ++mouseDown;
    }
    document.body.onmouseup = function () {
        --mouseDown;
    }

    let mousePos = {
        x: 0,
        y: 0
    };

    function getMousePos(e) {
        var rect = canvas.getBoundingClientRect();
        mousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }

    window.addEventListener('mousemove', getMousePos);

    class Circle {
        constructor(x) {
            this.x = x;
            this.y = canvas.height;
            this.direction = [0, 0];
        }

        update() {
            if (this.y > mousePos.y) {
                let x = mousePos.x - this.x;
                let y = mousePos.y - this.y;
                let h = Math.sqrt(x ** 2 + y ** 2);

                this.direction = [x / h, y / h];
            }

            this.x += this.direction[0] * 60;
            this.y += this.direction[1] * 60;
        }
    }

    let circles = [];

    (function init() {
        resizeCanvas();
        setInterval(spawnCircles, spawnRate);

        function run() {
            updateCircles();
            drawCircles();
            requestAnimationFrame(run);
        }

        requestAnimationFrame(run);
    })()

    function spawnCircles() {
        if (!mouseDown) return;
        for (let i = 0; i < columns; i++) {
            circles.push(new Circle(canvas.width * i / columns));
        }
    }

    function updateCircles() {
        for (circle of circles) {
            circle.update();
        }
        for (let i = 0; i < circles.length; i++) {
            if (circles[i].y < 0 || circles[i].x < 0 || circles[i].x > canvas.width) circles.splice(i, 1);
        }
    }

    function drawCircles() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        for (circle of circles) {
            context.beginPath();
            context.arc(circle.x, circle.y, radius, 0, 2 * Math.PI, false);
            context.fillStyle = `hsl(${circle.y / canvas.height * 360},100%,50%)`;
            context.fill();
            context.closePath();
        }
    }
</script>

</html>